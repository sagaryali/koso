import { NextRequest } from "next/server";
import Anthropic from "@anthropic-ai/sdk";
import { assembleContext } from "@/lib/embeddings/retrieve";
import { getAuthenticatedWorkspace } from "@/lib/api/get-workspace";
import type { SectionConfig } from "@/lib/section-config";

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

function isDemoMode() {
  return (
    process.env.NEXT_PUBLIC_DEMO_MODE === "true" ||
    !process.env.ANTHROPIC_API_KEY
  );
}

const SECTION_PROMPTS: Record<string, string> = {
  Problem:
    "Ground every statement in customer evidence. Cite specific feedback, metrics, or research. Do not speculate — if evidence is thin, say so.",
  "Goals & Success Metrics":
    "Each goal must map directly to a problem stated above. Define measurable success metrics tied to the evidence. If a goal lacks evidence support, flag it.",
  "User Stories":
    "Each story must trace to a goal above. Use personas derived from the customer evidence. Format: As a [persona], I want [action] so that [benefit].",
  Requirements:
    "Reference specific codebase modules and architecture constraints when available. Each requirement should be testable and traceable to a user story above.",
  "Open Questions":
    "Flag gaps, conflicts, and unresolved decisions across all prior sections. Prioritize questions that block engineering work.",
  // One-Pager sections
  "TL;DR":
    "One paragraph summarizing the proposal. Ground in evidence.",
  Context:
    "Why now? What has changed? Reference customer trends and market signals.",
  Proposal:
    "What are we doing and how? Reference codebase constraints when relevant.",
  "Risks & Mitigations":
    "Technical and product risks. Reference code architecture constraints.",
  "Next Steps":
    "Actionable next steps with clear ownership.",
  // User Story sections
  "User Story":
    "Ground the story in customer evidence and personas from feedback.",
  "Acceptance Criteria":
    "Specific, testable criteria. Reference code when relevant. Use Given/When/Then format.",
  Notes:
    "Additional context, dependencies, and open items.",
};

function createMockStream(sectionName: string): Response {
  const mockText = `This is a draft of the "${sectionName}" section based on the evidence and prior sections provided. The content would be generated by AI in production, referencing specific customer feedback, goals, and requirements from earlier sections.`;
  const encoder = new TextEncoder();
  const words = mockText.split(" ");

  const readable = new ReadableStream({
    start(controller) {
      let i = 0;
      const interval = setInterval(() => {
        if (i >= words.length) {
          controller.enqueue(encoder.encode("data: [DONE]\n\n"));
          controller.close();
          clearInterval(interval);
          return;
        }
        const chunk = (i > 0 ? " " : "") + words[i];
        const data = JSON.stringify({ text: chunk });
        controller.enqueue(encoder.encode(`data: ${data}\n\n`));
        i++;
      }, 25);
    },
  });

  return new Response(readable, {
    headers: {
      "Content-Type": "text/event-stream",
      "Cache-Control": "no-cache",
      Connection: "keep-alive",
    },
  });
}

export async function POST(request: NextRequest) {
  try {
    const auth = await getAuthenticatedWorkspace();
    if ("error" in auth) {
      return new Response(
        JSON.stringify({ error: auth.error }),
        { status: auth.status, headers: { "Content-Type": "application/json" } }
      );
    }

    const {
      sectionName,
      priorSections,
      sectionConfig,
      docTitle,
      productDescription,
      principles,
      workspaceId,
    } = (await request.json()) as {
      sectionName: string;
      priorSections: { heading: string; text: string }[];
      sectionConfig: SectionConfig;
      docTitle: string;
      productDescription?: string;
      principles?: string[];
      workspaceId: string;
    };

    if (!sectionName || !workspaceId) {
      return new Response(
        JSON.stringify({ error: "sectionName and workspaceId are required" }),
        { status: 400, headers: { "Content-Type": "application/json" } }
      );
    }

    if (isDemoMode()) {
      return createMockStream(sectionName);
    }

    // Fetch relevant context filtered by section config source types
    const searchQuery = priorSections.length > 0
      ? priorSections.map((s) => `${s.heading}: ${s.text}`).join("\n").slice(0, 1000)
      : docTitle;
    const context = await assembleContext(
      searchQuery,
      workspaceId,
      sectionConfig?.sourceTypes
    );

    // Build system prompt
    const systemParts: string[] = [
      "You are an AI assistant embedded in Koso, an IDE for product managers.",
      "You are drafting a specific section of a product specification.",
      "",
    ];

    if (productDescription) {
      systemParts.push(`Product: ${productDescription}`);
    }

    if (principles && principles.length > 0) {
      systemParts.push("Product Principles:");
      for (const p of principles) {
        systemParts.push(`- ${p}`);
      }
      systemParts.push("");
    }

    const sectionGuidance =
      SECTION_PROMPTS[sectionName] || sectionConfig?.guidance || "";

    systemParts.push(
      `You are writing the "${sectionName}" section of a spec titled "${docTitle}".`,
      "",
      sectionGuidance,
      "",
      "Write in clean, well-structured markdown. Use ## for sub-headings within the section, " +
        "**bold** for emphasis, and - for bullet points. " +
        "Be specific and actionable. Ground everything in the prior sections and evidence provided.",
      "",
      "Do NOT include the section heading itself — just write the content that goes under it.",
    );

    // Build user prompt with cascading context
    const userParts: string[] = [];

    // Prior sections (the cascade)
    if (priorSections.length > 0) {
      userParts.push("--- Prior Sections (already written) ---");
      userParts.push("");
      for (const section of priorSections) {
        userParts.push(`## ${section.heading}`);
        userParts.push(section.text);
        userParts.push("");
      }
    }

    // Customer evidence
    if (context.evidence.length > 0) {
      userParts.push("--- Customer Evidence ---");
      for (const e of context.evidence) {
        userParts.push(`- ${e.chunkText}`);
      }
      userParts.push("");
    }

    // Related specs
    if (context.artifacts.length > 0) {
      userParts.push("--- Related Specifications ---");
      for (const a of context.artifacts) {
        userParts.push(`- ${a.chunkText}`);
      }
      userParts.push("");
    }

    // Code context
    if (context.codebaseModules.length > 0) {
      userParts.push("--- Relevant Code Modules ---");
      for (const c of context.codebaseModules) {
        userParts.push(`- ${c.chunkText}`);
      }
      userParts.push("");
    }

    userParts.push("---");
    userParts.push("");
    userParts.push(
      `Now write the content for the "${sectionName}" section. Build on everything above.`
    );

    const stream = anthropic.messages.stream({
      model: "claude-sonnet-4-20250514",
      max_tokens: 4096,
      system: systemParts.join("\n"),
      messages: [{ role: "user", content: userParts.join("\n") }],
    });

    const encoder = new TextEncoder();

    const readable = new ReadableStream({
      async start(controller) {
        try {
          for await (const event of stream) {
            if (
              event.type === "content_block_delta" &&
              event.delta.type === "text_delta"
            ) {
              const data = JSON.stringify({ text: event.delta.text });
              controller.enqueue(encoder.encode(`data: ${data}\n\n`));
            }
          }
          controller.enqueue(encoder.encode("data: [DONE]\n\n"));
          controller.close();
        } catch (err) {
          const message =
            err instanceof Error ? err.message : "Stream error";
          const data = JSON.stringify({ error: message });
          controller.enqueue(encoder.encode(`data: ${data}\n\n`));
          controller.close();
        }
      },
    });

    return new Response(readable, {
      headers: {
        "Content-Type": "text/event-stream",
        "Cache-Control": "no-cache",
        Connection: "keep-alive",
      },
    });
  } catch (err) {
    console.error("[api/ai/draft-section] Error:", err);
    return new Response(
      JSON.stringify({ error: "Internal server error" }),
      { status: 500, headers: { "Content-Type": "application/json" } }
    );
  }
}
